\chapter{Educational software testing}\label{ch:dodona}

\section{Inleiding}\label{sec:inleiding}

\subsection{De digitale maatschappij}\label{subsec:de-digitale-maatschappij}

\lettrine{D}{e evoluties} op technologisch vlak hebben ervoor gezorgd dat onze maatschappij de laatste decennia in hoge mate gedigitaliseerd is, een proces dat nog steeds aan de gang is.
Bovendien kan, door de snelheid waarmee deze veranderingen vaak optreden, eerder gesproken worden van een revolutie dan een evolutie: de veranderingen zijn vaak ingrijpend en veranderen fundamentele aspecten van de sectoren waarin de digitalisering plaatsvindt.
Dit gaat over nieuwe sectoren, zoals de deeleconomie, of ingrijpende veranderingen bij bestaande sectoren, zoals de opkomst van \english{ride sharing} in de taxisector.
Ook de impact op maatschappelijk vlak, zoals de sociale media in de politiek, mag niet vergeten worden.
Al deze uitdagingen vragen een gepast antwoord, zoals onder andere \autocite{hipeac2019}.

Ook op educatief vlak heeft de digitalisering een grote impact.
Enerzijds biedt digitalisering nieuwe mogelijkheden aan voor onderwijsdoeleinden, zoals het lesgeven op afstand, het online aanbieden van leermateriaal en het online indien en verbeteren van opdrachten.

Anderzijds biedt het ook uitdagingen: om studenten voor te bereiden op de steeds digitalere maatschappij is een basis van digitale geletterdheid nodig.
Net door de snelle evolutie op technologisch vlak volstaat het niet om studenten te leren werken met de technologie van vandaag;
een grondige kennis van de onderliggende werking van de technologie is onontbeerlijk.

Een belangrijk aspect hierin is het concept van \term{computationeel denken}.
Dit concept gaat over het omvormen van problemen zodat de door een computer opgelost kunnen worden.
Dat het aanleren van deze vaardigheden nodig is, bewijst ook de opname van computationeel denken in de eindtermen, bijvoorbeeld in het katholieke basisonderwijs \autocite{zinin2017} of in de onderwijsdoelen voor het secundair onderwijs als \term{Computationeel denken en handelen} \autocite{2019040867}.

\subsection{Computationeel denken}\label{subsec:computationeel-denken}

Over de vraag wat computationeel denken nu precies betekent lopen de antwoorden uiteen.
Het Departement Onderwijs en Vorming van de Vlaams Overheid \autocite{bastiaensen2017} definieert de term als volgt:

\begin{quote}
    Computationeel denken verwijst dus naar het menselijke vermogen om complexe problemen op te lossen en daarbij computers als hulpmiddel te zien.
    Met andere woorden, computationeel denken is het proces waarbij aspecten van informaticawetenschappen herkend worden in de ons omringende wereld, en waarbij de methodes en technieken uit de informaticawetenschappen toegepast worden om problemen uit de fysische en virtuele wereld te begrijpen en op te lossen.
\end{quote}

Computationeel denken is dus ruimer dan programmeren, maar programmeren vormt wel een uitstekende manier om het computationeel denken aan te leren en te oefenen.
Bovendien is programmeren op zich ook een nuttige vaardigheid om studenten aan te leren.

\subsection{Programmeeroefeningen}\label{subsec:programmeeroefeningen}

Het aanleren van programmeren is niet eenvoudig en wordt door veel studenten als moeilijk ervaren \autocite{10.1145/3293881.3295779}.
Het maken van oefeningen kan daarbij helpen, indachtig het spreekwoord "oefening baart kunst".
De studenten veel oefeningen laten maken, resulteert wel in twee uitdagingen voor de lesgevers:
\begin{enumerate}
    \item De lesgevers moeten geschikte oefeningen opstellen, die rekening houden met welke programmeerconcepten studenten al kennen, tijdslimieten, moeilijkheidsgraden, enz.
    Het opstellen van deze oefeningen vraagt veel tijd.
    \item De oplossingen voor deze oefeningen moeten voorzien worden van kwalitatieve feedback.
    Bij het aanleren van programmeren is feedback namelijk een belangrijk element om de programmeervaardigheden van de studenten te verbeteren \autocite{10.1145/2899415.2899422}.
\end{enumerate}

Deze thesis focust op de eerste uitdaging, al wordt ook met de tweede uitdaging rekening gehouden, onder andere in \cref{sec:robuustheid}.
Hiervoor werkt de thesis binnen de context van Dodona, een online leerplatform dat sinds september 2016 beschikbaar is aan de Universiteit Gent.

\section{Het leerplatform Dodona}\label{sec:wat-is-dodona}

Sinds 2011 wordt aan de vakgroep Computationele Biologie aan de Universiteit Gent gewerkt met programmeeroefeningen die in een online systeem ingediend en beoordeeld worden.
Oorspronkelijk werd hiervoor gebruik gemaakt van de \english{Sphere Online Judge} (SPOJ) \autocite{10.1007/978-3-540-78139-4_31}.
Op basis van ervaringen met SPOJ ontwikkelde de vakgroep een eigen leerplatform, Dodona, dat in september 2016 beschikbaar werd.
Het doel van Dodona is eenvoudig: lesgevers bijstaan om hun studenten niet alleen zo goed mogelijk te leren programmeren, maar dit ook op een zo efficiënt mogelijke manier te doen.

Het online leerplatform Dodona kunnen we opdelen in verschillende onderdelen:
\begin{enumerate}
    \item Het platform zelf.
    Dit is een webapplicatie, die verantwoordelijk is om alle modules samen te laten werken en ook de webinterface aanbiedt die de studenten en lesgevers gebruiken.
    Het is via deze interface dat lesgevers oefeningen beschikbaar maken en dat studenten hun oplossingen indienen.
    Het platform zelf is programmeertaalonafhankelijk geschreven.
    \item Judges.
    De judges binnen Dodona zijn verantwoordelijk voor het beoordelen van ingediende oplossingen.
    Dit onderdeel wordt uitgebreid besproken in \cref{subsec:de-judge}.
    \item Oefeningen.
    Oefeningen worden niet in Dodona zelf opgeslagen, maar worden door de lesgever aangeleverd via een git-repository.
    De oefeningen bevatten de opgave en de testen die uitgevoerd worden tijdens de beoordeling van een oplossing.
\end{enumerate}

Met Dodona kunnen lesgevers een leertraject opstellen door een reeks oefeningen te selecteren.
Studenten die dit leertraject volgen, zien onmiddellijk hun voortgang binnen het traject.
Bij het indienen van hun oplossingen ontvangen de studenten ook onmiddellijk feedback over hun oplossing: deze feedback bevat niet alleen de juistheid van de oplossing, maar kan ook andere aspecten belichten, zoals de kwaliteit en performantie van de oplossing.

\section{Beoordelen van oplossingen}\label{sec:evalueren-van-een-oplossing}

\subsection{De judge}\label{subsec:de-judge}

In Dodona wordt elke ingediende oplossing beoordeeld door een evaluatieprogramma, de \termen{judge}.
In wezen is dit een eenvoudig programma: via de standaardinvoerstroom (\texttt{stdin}) krijgt het programma een configuratie binnen van Dodona.
Deze configuratie bevat de invoer, bestaande uit onder andere de programmeertaal van de oplossing, het pad naar het oplossingsbestand en geheugen- en tijdslimieten.
Het resultaat van de beoordeling wordt uitgeschreven naar de standaarduitvoerstroom (\texttt{stdout}).
Zowel de invoer als de uitvoer van de judge zijn json, waarvan het formaat vastgelegd is in een json-schema.\footnote{Dit schema en een tekstuele beschrijving ervan is te vinden in de handleiding op \url{https://dodona-edu.github.io/en/guides/creating-a-judge/}.}

Concreet wordt elke beoordeling uitgevoerd in een Docker-container.
Deze Docker-container wordt gemaakt op basis van een Docker-image die bij de judge hoort, en alle dependencies bevat die de judge in kwestie nodig heeft.
Bij het uitvoeren van de beoordeling zal Dodona een \english{bind mount}\footnote{Informatie over deze term vindt u op \url{https://docs.docker.com/storage/bind-mounts/}} voorzien, zodat de code van de judge zelf, de code van de oefening en de code van de student beschikbaar zijn in de container.
Via de configuratie geeft Dodona aan de judge aan waar deze bestanden zich bevinden.

Samenvattend bestaat interface tussen de judge en Dodona uit drie onderdelen:

\begin{enumerate}
    \item De judge zal uitgevoerd worden in een Docker-container, dus een Docker-image met alle dependencies moet voorzien worden.
    Deze Docker-image moet ook de judge opstarten.
    \item De judge stelt de invoer van een beoordeling ter beschikking voor de judge.
    Bestanden worden via een bind mount aan de Docker-container gekoppeld.
    De paden naar deze bestanden binnen de container en andere informatie (zoals programmeertaal van de oplossing of natuurlijke taal van de gebruiker) worden via de configuratie aan de judge gegeven (via standaardinvoer).
    \item De judge moet het resultaat van zijn beoordeling uitschrijven naar standaarduitvoer, in een vastgelegd formaat.
\end{enumerate}

Buiten deze interface legt Dodona geen vereisten op aan de werking van judge.
Door deze vrijheid lopen de manieren waarop de bestaande judges geïmplementeerd zijn uiteen.
Sommige judges beoordelen oplossingen in dezelfde programmeertaal als de taal waarin ze geschreven zijn.
Zo is de judge voor Python-oplossingen geschreven in Python en de judge voor Java-oplossingen in Java.
Bij andere judges is dat niet het geval: de judges voor Bash en Prolog zijn bijvoorbeeld ook in Python geschreven.
Ook heeft elke judge een eigen manier waarop de testen voor een oplossing opgesteld moeten worden.
Zo worden in de Java-judge jUnit-testen gebruikt, terwijl de Python-judge doctests en een eigen formaat ondersteunt.

\subsection{De beoordeling zelf}\label{subsec:de-beoordeling-zelf}

De beoordeling van een oplossing van een student laat zich beschreven als het volgende stappenplan:

\begin{enumerate}
    \item De student dient de oplossing in via de webinterface van Dodona.
    \item Dodona start een Docker-container voor de judge.
    \item Dodona voorziet de container van de bestanden van de judge, de oefening en de ingediende oplossing.
    \item De judge wordt uitgevoerd met de configuratie als invoer.
    \item De judge beoordeelt de oplossing aan de beoordelingsmethodes opgesteld door de lesgever (d.w.z.\ de jUnit-test, de doctests, \ldots).
    Sommige judges voeren ook bijkomende taken, zoals linting, beoordeling van de performantie of \english{grading} van de code van de oplossing.
    \item De judge vertaalt zijn beoordeling naar het Dodona-formaat en schrijft het resultaat naar het standaarduitvoerkanaal.
    \item Dodona slaat dat resultaat op in de databank.
    \item Op de webinterface krijgt de student het resultaat te zien als feedback op de ingediende oplossing.
\end{enumerate}



\section{Probleemstelling}\label{sec:probleemstelling}

De manier waarop de huidige judges werken, resulteert in twee belangrijke nadelen.
Bij het bespreken hiervan is het nuttig een voorbeeld in het achterhoofd te houden, teneinde de nadelen te kunnen concretiseren.
Als voorbeeld gebruiken we de "Lotto"-oefening\footnote{Vrij naar een oefening van prof.\ Dawyndt. De originele oefening is beschikbaar op \url{https://dodona.ugent.be/nl/exercises/2025591548/}}, met volgende opgave:

\begin{quote}
    \markdownInput{generated/description.md}
\end{quote}

Oplossingen voor deze oefening staan in \cref{lst:java-solution,lst:python-solution}, voor respectievelijk Python en Java.

\begin{listing}
    \inputminted{java}{../../exercise/lotto/solution/correct.java}
    \caption{Voorbeeldoplossing in Java.}
    \label{lst:java-solution}
\end{listing}

\begin{listing}
    \inputminted{python3}{../../exercise/lotto/solution/correct.py}
    \caption{Voorbeeldoplossing in Python.}
    \label{lst:python-solution}
\end{listing}

\subsubsection{Implementatie van oefeningen}

Het eerste en belangrijkste nadeel aan de werking van de huidige judges heeft betrekking op de lesgevers en komt voor als zij een oefening willen aanbieden in meerdere programmeertalen.
Enerzijds is dit een zware werklast: de oefening, en vooral de code voor de beoordeling, moet voor elke judge opnieuw geschreven worden.
Voor de Python-judge zullen doctests nodig zijn, terwijl de Java-judge jUnit-testen vereist.
Anderzijds lijdt dit ook tot verschillende versies van dezelfde oefening, wat het onderhouden van de oefeningen moelijker maakt.
Als er bijvoorbeeld een fout sluipt in de beoordelingscode, zal de lesgever er aan moeten denken om de fout te verhelpen in alle varianten van de oefening.
Bovendien geeft elke nieuwe versie van de oefening een nieuwe mogelijkheid voor het introduceren van fouten.

Kijken we naar onze Lotto-oefening, merken we dat het gaat om een eenvoudige opgave en een eenvoudige oplossing.
Bovendien zijn de verschillen tussen oplossingen in verschillende programmeertalen niet zo groot.
In de voorbeeldoplossingen in Python en Java zijn de verschillen minimaal, zij het dat de Java-oplossing wat langer is.
De Lotto-oefening zou zonder problemen in nog vele andere programmeertalen opgelost kunnen worden.
Eenvoudige programmeeroefeningen, zoals de Lotto-oefening, zijn voornamelijk nuttig in twee gevallen: studenten die voor het eerst leren programmeren en studenten die een nieuwe programmeertaal leren.
In het eerste geval is de eigenlijke programmeertaal minder relevant: het zijn vooral de concepten die belangrijk zijn.
In het tweede geval is de programmeertaal wel van belang, maar moeten soortgelijke oefeningen gemaakt worden voor elke programmeertaal die aangeleerd moet worden.
In beide gevallen is het dus een meerwaarde om de oefening in meerdere programmeertalen aan te bieden.

We kunnen tot eenzelfde constatatie komen bij meer complexe oefeningen die zich concentreren op algoritmen: ook daar zijn de concepten belangrijker dan in welke programmeertaal een algoritme uiteindelijk geïmplementeerd wordt.
Een voorbeeld hiervan is het vak "Algoritmen en Datastructuren" dat gegeven wordt door prof.\ Fack binnen de opleiding wiskunde\footnote{De studiefiche is beschikbaar op \url{https://studiegids.ugent.be/2019/NL/studiefiches/C002794.pdf}}.
Daar zijn de meeste opgaven vandaag al beschikbaar in Java en Python op Dodona, maar dan als afzonderlijke oefeningen.

Een ander aspect is de beoordeling van een oefening.
Voor de Lotto-oefening is de beoordeling niet triviaal, door het gebruik van niet-deterministische functies.
Het volstaat voor dit soort oefeningen niet om de uitvoer gegenereerd door de oplossing te vergelijken met een op voorhand vastgelegde verwachte uitvoer.
De geproduceerde uitvoer zal moeten gecontroleerd worden met code, specifiek gericht op deze oefening, die de verwachte vereisten van de oplossing controleert.
Deze evaluatiecode moet momenteel voor elke programmeertaal en dus elke judge opnieuw geschreven worden.
In de context van de Lotto-oefening controleert deze code bijvoorbeeld of de gegeven getallen binnen het bereik liggen en of ze gesorteerd zijn.

\subsubsection{Implementatie van judges}

Een tweede nadeel aan de werking zijn de judges zelf: voor elke programmeertaal die men wil aanbieden in Dodona moet een nieuwe judge ontwikkeld worden.
Ook hier is er dubbel werk: dezelfde concepten en features, die eigenlijk programmeertaalonafhankelijk zijn, moeten in elke judge opnieuw geïmplementeerd worden.
Hierbij denken we aan bijvoorbeeld de logica om te bepalen wanneer een beoordeling positief of negatief moet zijn.

\subsubsection{Onderzoeksvraag}

We beschouwen het eerste nadeel als het belangrijkste nadeel, en vatten het samen als de onderzoeksvraag waarop deze thesis een antwoord wil bieden:

\begin{quote}
    Is het mogelijk om een judge zo te implementeren dat de opgave en beoordelingsmethoden van een oefening slechts eenmaal opgesteld dienen te worden, waarna de oefening beschikbaar is in alle programmeertalen die de judge ondersteunt?
    Hierbij willen we dat eens een oefening opgesteld is, deze niet meer gewijzigd moet worden wanneer talen toegevoegd worden aan de judge.
\end{quote}

Als bijzaak zijn we ook geïnteresseerd of de judge uit de onderzoeksvraag een voordeel kan bieden voor het implementeren van judges zelf (het tweede nadeel).

De aandachtige lezer zal opmerken dat de opgave voor de Lotto-oefening programmeertaalspecifieke en taalspecifieke elementen bevat.
Zo zijn de voorbeelden in Python en zijn de namen van functies en argumenten in het Nederlands.
Beide zaken worden voor deze thesis expliciet als \english{out-of-scope} gezien en zullen niet behandeld worden.

\section{Opbouw van de thesis}\label{sec:opbouw}

\Cref{ch:de-universele-judge} handelt over het antwoord op bovenstaande vraag, waar een prototype van een dergelijke judge wordt voorgesteld.
Daarna volgt ter illustratie een gedetailleerde beschrijving van hoe een oefening opgesteld moet worden voor deze judge.
Nadien volgt een beschrijving van hoe een nieuwe programmeertaal moet toegevoegd worden.
Daar deze twee hoofdstukken voornamelijk ten doel hebben zij die met de judge moeten werken te informeren, nemen deze hoofdstukken de vorm aan van meer traditionele softwarehandleidingen.
Tot slot volgt met een hoofdstuk over beperkingen van de huidige implementaties, en waar er verbeteringen mogelijk zijn (het "toekomstige werk").
